// Fill out your copyright notice in the Description page of Project Settings.

#include "OutputBuffer.h"


	// Called when the game starts
void UOutputBuffer::BeginPlay()
{
	Super::BeginPlay();
	//Yin_Init(300);
}

void UOutputBuffer::CustomDSP(float sample) {
	FString TheFloatStr = FString::SanitizeFloat(sample);
	GEngine->AddOnScreenDebugMessage(-1, 1.0, FColor::Red, *TheFloatStr);
}



void UOutputBuffer::TestData() {
	audioData = {
	19,
		24,
		29,
		34,
		38,
		42,
		46,
		49,
		52,
		54,
		56,
		58,
		59,
		60,
		61,
		61,
		60,
		60,
		59,
		58,
		56,
		54,
		52,
		49,
		47,
		44,
		41,
		39,
		36,
		34,
		32,
		29,
		27,
		24,
		21,
		18,
		15,
		12,
		9,
		5,
		2,
		0,
		-3,
		-6,
		-9,
		-12,
		-14,
		-17,
		-19,
		-21,
		-23,
		-25,
		-27,
		-29,
		-31,
		-33,
		-35,
		-37,
		-39,
		-41,
		-43,
		-44,
		-45,
		-46,
		-47,
		-48,
		-48,
		-48,
		-48,
		-47,
		-46,
		-45,
		-44,
		-43,
		-41,
		-40,
		-38,
		-37,
		-35,
		-34,
		-32,
		-31,
		-30,
		-28,
		-27,
		-26,
		-24,
		-23,
		-22,
		-21,
		-20,
		-18,
		-18,
		-17,
		-17,
		-17,
		-17,
		-18,
		-19,
		-21,
		-22,
		-24,
		-26,
		-28,
		-30,
		-31,
		-33,
		-35,
		-37,
		-40,
		-42,
		-44,
		-47,
		-50,
		-52,
		-56,
		-59,
		-63,
		-67,
		-71,
		-75,
		-79,
		-82,
		-86,
		-89,
		-92,
		-95,
		-98,
		-101,
		-103,
		-105,
		-107,
		-109,
		-111,
		-112,
		-114,
		-115,
		-117,
		-118,
		-120,
		-121,
		-122,
		-122,
		-123,
		-123,
		-123,
		-123,
		-122,
		-121,
		-120,
		-119,
		-117,
		-116,
		-114,
		-112,
		-109,
		-107,
		-104,
		-101,
		-98,
		-95,
		-92,
		-89,
		-85,
		-81,
		-77,
		-73,
		-69,
		-65,
		-61,
		-56,
		-52,
		-47,
		-43,
		-39,
		-35,
		-31,
		-28,
		-24,
		-20,
		-16,
		-12,
		-8,
		-4,
		0,
		3,
		7,
		11,
		15,
		20,
		24,
		28,
		32,
		36,
		40,
		44,
		47,
		51,
		54,
		57,
		60,
		62,
		64,
		65,
		67,
		68,
		70,
		71,
		73,
		74,
		76,
		77,
		79,
		81,
		83,
		85,
		88,
		90,
		92,
		95,
		97,
		99,
		101,
		103,
		104,
		105,
		106,
		106,
		106,
		106,
		105,
		104,
		104,
		103,
		102,
		102,
		101,
		102,
		102,
		103,
		104,
		106,
		107,
		109,
		111,
		112,
		114,
		115,
		115,
		116,
		116,
		115,
		114,
		113,
		112,
		111,
		109,
		108,
		107,
		106,
		105,
		105,
		105,
		105,
		106,
		107,
		108,
		109,
		110,
		112,
		112,
		113,
		113,
		113,
		113,
		112,
		111,
		110,
		109,
		107,
		105,
		104,
		103,
		101,
		100,
		99,
		99,
		98,
		98,
		98,
		98,
		97,
		97,
		97,
		96,
		95,
		94,
		93,
		91,
		90,
		89,
		87,
		85,
		84,
		82,
		81,
		80,
		79,
		78,
		76,
		75,
		74,
		73,
		71,
		70,
		68,
		66,
		64,
		63,
		61,
		59,
		57,
		56,
		54,
		52,
		51,
		49,
		48,
		47,
		46,
		46,
		45,
		45,
		44,
		44,
		43,
		42,
		41,
		40,
		38,
		37,
		35,
		33,
		31,
		29,
		27,
		25,
		23,
		22,
		20,
		19,
		18,
		17,
		17,
		17,
		17,
		17,
		17,
		18,
		18,
		19,
		19,
		20,
		19,
		19,
		18,
		17,
		16,
		14,
		12,
		11,
		9,
		8,
		6,
		5,
		4,
		3,
		2,
		2,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		-1,
		-2,
		-3,
		-5,
		-6,
		-8,
		-9,
		-10,
		-12,
		-13,
		-13,
		-14,
		-15,
		-15,
		-16,
		-16,
		-17,
		-17,
		-18,
		-19,
		-20,
		-21,
		-22,
		-23,
		-24,
		-25,
		-26,
		-27,
		-27,
		-28,
		-29,
		-29,
		-30,
		-31,
		-32,
		-32,
		-33,
		-34,
		-34,
		-35,
		-35,
		-36,
		-36,
		-37,
		-37,
		-38,
		-38,
		-39,
		-39,
		-39,
		-39,
		-39,
		-39,
		-39,
		-40,
		-40,
		-40,
		-40,
		-40,
		-39,
		-39,
		-39,
		-38,
		-38,
		-38,
		-37,
		-37,
		-37,
		-38,
		-38,
		-39,
		-40,
		-41,
		-42,
		-43,
		-44,
		-44,
		-45,
		-46,
		-46,
		-47,
		-47,
		-48,
		-49,
		-50,
		-51,
		-53,
		-55,
		-58,
		-61,
		-64,
		-67,
		-70,
		-73,
		-76,
		-79,
		-83,
		-86,
		-90,
		-93,
		-97,
		-101,
		-105,
		-109,
		-112,
		-115,
		-117,
		-119,
		-121,
		-122,
		-123,
		-123,
		-123,
		-123,
		-122,
		-121,
		-119,
		-118,
		-116,
		-115,
		-113,
		-112,
		-109,
		-106,
		-103,
		-99,
		-94,
		-90,
		-85,
		-80,
		-75,
		-69,
		-64,
		-58,
		-52,
		-46,
		-40,
		-33,
		-27,
		-20,
		-14,
		-8,
		-1,
		4,
		10,
		16,
		22,
		27,
		33,
		39,
		44,
		49,
		54,
		59,
		63,
		67,
		70,
		72,
		74,
		76,
		77,
		78,
		78,
		78,
		77,
		76,
		75,
		73,
		72,
		70,
		68,
		66,
		64,
		62,
		59,
		57,
		55,
		53,
		50,
		47,
		43,
		40,
		35,
		31,
		27,
		22,
		18,
		14,
		10,
		6,
		2,
		0,
		-4,
		-7,
		-10,
		-14,
		-17,
		-21,
		-24,
		-28,
		-32,
		-35,
		-38,
		-41,
		-43,
		-46,
		-48,
		-50,
		-51,
		-52,
		-52,
		-52,
		-52,
		-51,
		-50,
		-50,
		-49,
		-47,
		-46,
		-45,
		-44,
		-44,
		-43,
		-42,
		-41,
		-40,
		-39,
		-38,
		-36,
		-34,
		-33,
		-31,
		-29,
		-28,
		-26,
		-24,
		-23,
		-22,
		-21,
		-21,
		-20,
		-20,
		-20,
		-20,
		-21,
		-22,
		-23,
		-25,
		-27,
		-29,
		-32,
		-35,
		-38,
		-41,
		-44,
		-48,
		-51,
		-55,
		-58,
		-62,
		-66,
		-70,
		-73,
		-77,
		-81,
		-85,
		-88,
		-92,
		-95,
		-99,
		-103,
		-106,
		-110,
		-113,
		-116,
		-119,
		-122,
		-124,
		-127,
		-130,
		-133,
		-136,
		-139,
		-141,
		-144,
		-146,
		-148,
		-149,
		-150,
		-151,
		-151,
		-151,
		-151,
		-151,
		-150,
		-149,
		-148,
		-146,
		-144,
		-142,
		-139,
		-137,
		-134,
		-131,
		-129,
		-126,
		-123,
		-120,
		-117,
		-114,
		-111,
		-108,
		-104,
		-101,
		-98,
		-94,
		-91,
		-87,
		-82,
		-77,
		-72,
		-67,
		-61,
		-55,
		-48,
		-42,
		-36,
		-30,
		-24,
		-18,
		-13,
		-8,
		-3,
		0,
		3,
		6,
		9,
		12,
		14,
		17,
		20,
		23,
		26,
		30,
		34,
		38,
		43,
		48,
		52,
		57,
		62,
		67,
		71,
		74,
		78,
		81,
		83,
		85,
		86,
		87,
		87,
		87,
		87,
		88,
		89,
		90,
		91,
		92,
		94,
		96,
		98,
		100,
		102,
		105,
		107,
		109,
		111,
		113,
		114,
		115,
		116,
		116,
		116,
		116,
		115,
		115,
		115,
		114,
		114,
		114,
		114,
		114,
		114,
		115,
		115,
		116,
		117,
		117,
		117,
		118,
		118,
		118,
		118,
		118,
		118,
		118,
		118,
		118,
		118,
		118,
		118,
		118,
		118,
		118,
		118,
		118,
		117,
		117,
		117,
		117,
		116,
		116,
		116,
		115,
		115,
		114,
		113,
		112,
		111,
		110,
		109,
		108,
		108,
		107,
		107,
		106,
		106,
		106,
		106,
		106,
		106,
		105,
		105,
		104,
		103,
		101,
		100,
		98,
		96,
		94,
		92,
		90,
		88,
		86,
		85,
		83,
		81,
		80,
		78,
		77,
		76,
		75,
		75,
		75,
		75,
		75,
		74,
		74,
		73,
		72,
		71,
		70,
		68,
		67,
		65,
		63,
		60,
		58,
		56,
		54,
		52,
		50,
		48,
		47,
		46,
		46,
		45,
		45,
		44,
		44,
		44,
		43,
		43,
		43,
		42,
		41,
		41,
		40,
		39,
		38,
		38,
		37,
		36,
		36,
		35,
		34,
		34,
		33,
		32,
		32,
		31,
		30,
		29,
		29,
		28,
		28,
		28,
		27,
		27,
		27,
		26,
		25,
		25,
		24,
		23,
		22,
		21,
		20,
		20,
		19,
		19,
		18,
		17,
		17,
		16,
		16,
		15,
		15,
		14,
		13,
		12,
		11,
		9,
		8,
		7,
		5,
		4,
		3,
		3,
		2,
		1,
		0,
		0,
		0,
		-1,
		-1,
		-2,
		-3,
		-3,
		-4,
		-6,
		-7,
		-8,
		-10,
		-11,
		-12,
		-13,
		-14,
		-16,
		-17,
		-18,
		-19,
		-20,
		-21,
		-22,
		-23,
		-24,
		-25,
		-25,
		-25,
		-25,
		-26,
		-26,
		-26,
		-26,
		-27,
		-27,
		-28,
		-29,
		-29,
		-30,
		-31,
		-31,
		-32,
		-33,
		-34,
		-34,
		-35,
		-35,
		-35,
		-35,
		-35,
		-35,
		-34,
		-34,
		-34,
		-33,
		-33,
		-33,
		-33,
		-33,
		-33,
		-34,
		-34,
		-35,
		-36,
		-38,
		-40,
		-42,
		-45,
		-48,
		-51,
		-53,
		-56,
		-59,
		-62,
		-65,
		-69,
		-72,
		-75,
		-79,
		-82,
		-85,
		-88,
		-91,
		-95,
		-99,
		-104,
		-108,
		-111,
		-115,
		-118,
		-122,
		-125,
		-127,
		-130,
		-131,
		-133,
		-134,
		-134,
		-135,
		-135,
		-135,
		-134,
		-134,
		-133,
	};
}


void UOutputBuffer::MakeAudio(TArray<float> inputSample, int sampleSize) {
	//making audio data
	audioData.Reset(sampleSize);
	audioData = inputSample;


	//TestData();
	//sampleSize = 1025+22;

	/*
	for (int i = 0; i < sampleSize; i++) {
		FString TheFloatStr = FString::SanitizeFloat(audioData[i]);
		GEngine->AddOnScreenDebugMessage(-1, 1.0, FColor::Red, *TheFloatStr);
	}
	*/

	Yin_Init(sampleSize);

	FString TheFloatStr = FString::SanitizeFloat(sampleSize);
	//GEngine->AddOnScreenDebugMessage(-1, 1.0, FColor::Red, *TheFloatStr);
}

void UOutputBuffer::YinPitchTracking() {
	float pitch = 0;
	float periodicity = 0;

	pitch = Yin_getPitch(audioData);
	//periodicity = Yin_getProbability();


	//if (pitch  != -1) {
		FString str1 = "Pitch is found to be ";
		FString sPitch = FString::SanitizeFloat(pitch);
		FString str2 = " with window size ";
		FString sBufferLength = FString::SanitizeFloat(this->bufferSize);
		FString str3 = " and probabilty ";
		FString sProbability = FString::SanitizeFloat(Yin_getProbability());

		str1.Append(sPitch);
		str1.Append(str2);
		str1.Append(sBufferLength);
		str1.Append(str3);
		str1.Append(sProbability);

		GEngine->AddOnScreenDebugMessage(-1, 10.0, FColor::Red, *str1);
	//}
}

void UOutputBuffer::Yin_Init(int bufferSize) {
	this->bufferSize = bufferSize;
	this->halfBufferSize = bufferSize / 2;
	this->probability = 0.0f;
	this->threshold = YIN_THRESHOLD;
	//this->threshold = 1.0f;

	this->yinBuffer = (float *)malloc(sizeof(float)* this->halfBufferSize);
	for (int i = 0; i < this->halfBufferSize; i++) {
		this->yinBuffer[i] = 0;
	}
}

float UOutputBuffer::Yin_getPitch(TArray<float> buffer) {
	int tauEstimate = -1;
	float pitchInHertz = -1;

	/* Step 1: Calculates the squared difference of the signal with a shifted version of itself. */
	Yin_difference(buffer);

	/* Step 2: Calculate the cumulative mean on the normalised difference calculated in step 1 */
	Yin_cumulativeMeanNormalizedDifference();

	/* Step 3: Search through the normalised cumulative mean array and find values that are over the threshold */
	tauEstimate = Yin_absoluteThreshold();

	/* Step 5: Interpolate the shift value (tau) to improve the pitch estimate. */
	if (tauEstimate != -1) {
		pitchInHertz = YIN_SAMPLING_RATE / Yin_parabolicInterpolation(tauEstimate);
	}

	return pitchInHertz;
}


float UOutputBuffer::Yin_getProbability() {
	return this->probability;
}

/*Internal Functions*/
void UOutputBuffer::Yin_difference(TArray<float> &buffer) {
	int i, tau;
	float delta;

	/* Calculate the difference for difference shift values (tau) for the half of the samples */
	for (tau = 0; tau < this->halfBufferSize; tau++) {
		/* Take the difference of the signal with a shifted version of itself, then square it.
		* (This is the Yin algorithm's tweak on autocorellation) */
		for (i = 0; i < this->halfBufferSize; i++) {
			delta = buffer[i] - buffer[i + tau];
			this->yinBuffer[tau] += delta * delta;
			//FString sPitch = FString::SanitizeFloat(this->yinBuffer[tau]);
			//GEngine->AddOnScreenDebugMessage(-1, 10.0, FColor::Red, *sPitch);
		}
	}
}

void UOutputBuffer::Yin_cumulativeMeanNormalizedDifference() {
	int tau;
	float runningSum = 0;
	this->yinBuffer[0] = 1;

	/* Sum all the values in the autocorellation buffer and nomalise the result, replacing
	* the value in the autocorellation buffer with a cumulative mean of the normalised difference */
	for (tau = 1; tau < this->halfBufferSize; tau++) {
		runningSum += this->yinBuffer[tau];
		this->yinBuffer[tau] *= tau / runningSum;
	}
}

int UOutputBuffer::Yin_absoluteThreshold() {
	int tau;

	/* Search through the array of cumulative mean values, and look for ones that are over the threshold
	* The first two positions in yinBuffer are always so start at the third (index 2) */
	for (tau = 2; tau < this->halfBufferSize; tau++) {
		
		if (yinBuffer[tau] < 0.9) {
			FString str2 = "The value in ";
			str2.Append(FString::SanitizeFloat(tau));
			str2.Append(" is ");
			str2.Append(FString::SanitizeFloat(yinBuffer[tau]));
			str2.Append("\n");
			//GEngine->AddOnScreenDebugMessage(-1, 10.0, FColor::Red, *str2);
		}

		if (this->yinBuffer[tau] < this->threshold) {
			while (tau + 1 < this->halfBufferSize && this->yinBuffer[tau + 1] < this->yinBuffer[tau]) {
				FString str3 = "While Loop: ";
				str3.Append(FString::SanitizeFloat(tau));
				str3.Append("\n");
				//GEngine->AddOnScreenDebugMessage(-1, 10.0, FColor::Red, *str3);
				tau++;
			}
			/* found tau, exit loop and return
			* store the probability
			* From the YIN paper: The yin->threshold determines the list of
			* candidates admitted to the set, and can be interpreted as the
			* proportion of aperiodic power tolerated
			* within a periodic signal.
			*
			* Since we want the periodicity and and not aperiodicity:
			* periodicity = 1 - aperiodicity */
			this->probability = 1 - this->yinBuffer[tau];
			break;
		}
	}

	FString str = "tau is found to be: ";
	FString sTau = FString::SanitizeFloat(tau);
	FString sValueAtTau = FString::SanitizeFloat(yinBuffer[tau]);
	FString sBufferSize = FString::SanitizeFloat(this->halfBufferSize);

	str.Append(sTau);
	str.Append(" with value: ");
	str.Append(sValueAtTau);
	str.Append(". The Yin Buffer Size is: ");
	str.Append(sBufferSize);
	str.Append("\n");
	
	GEngine->AddOnScreenDebugMessage(-1, 10.0, FColor::Red, *str);

	/* if no pitch found, tau => -1 */
	if (tau == this->halfBufferSize || this->yinBuffer[tau] >= this->threshold) {
		tau = -1;
		this->probability = 0;
	}



	return tau;
}

float UOutputBuffer::Yin_parabolicInterpolation(int tauEstimate) {
	float betterTau;
	int x0, x2;

	/* Calculate the first polynomial coeffcient based on the current estimate of tau */
	if (tauEstimate < 1) {
		x0 = tauEstimate;
	}
	else {
		x0 = tauEstimate - 1;
	}

	/* Calculate the second polynomial coeffcient based on the current estimate of tau */
	if (tauEstimate + 1 < this->halfBufferSize) {
		x2 = tauEstimate + 1;
	}
	else {
		x2 = tauEstimate;
	}

	/* Algorithm to parabolically interpolate the shift value tau to find a better estimate */
	if (x0 == tauEstimate) {
		if (this->yinBuffer[tauEstimate] <= this->yinBuffer[x2]) {
			betterTau = tauEstimate;
		}
		else {
			betterTau = x2;
		}
	}
	else if (x2 == tauEstimate) {
		if (this->yinBuffer[tauEstimate] <= this->yinBuffer[x0]) {
			betterTau = tauEstimate;
		}
		else {
			betterTau = x0;
		}
	}
	else {
		float s0, s1, s2;
		s0 = this->yinBuffer[x0];
		s1 = this->yinBuffer[tauEstimate];
		s2 = this->yinBuffer[x2];
		// fixed AUBIO implementation, thanks to Karl Helgason:
		// (2.0f * s1 - s2 - s0) was incorrectly multiplied with -1
		betterTau = tauEstimate + (s2 - s0) / (2 * (2 * s1 - s2 - s0));
	}


	return betterTau;
}


